# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:32:45+00:00

from __future__ import annotations

from datetime import datetime as datetime_aliased
from enum import Enum
from typing import Dict, List, Optional, Union
from uuid import UUID

from pydantic import BaseModel, Field


class FunctionType(Enum):
    PRE_ACTION_EXECUTION = 'PRE_ACTION_EXECUTION'
    PRE_FETCH_OPTIONS = 'PRE_FETCH_OPTIONS'
    POST_FETCH_OPTIONS = 'POST_FETCH_OPTIONS'


class ActionFunction(BaseModel):
    functionSource: str = Field(..., description='The function source code.')
    functionType: FunctionType = Field(
        ...,
        description='The type of function. This determines when the function will be called.',
    )
    id: Optional[str] = Field(
        None,
        description='The ID qualifier for the function. This is used to specify which input field a function is associated with for `PRE_FETCH_OPTIONS` and `POST_FETCH_OPTIONS` function types.',
    )


class ActionFunctionIdentifier(BaseModel):
    functionType: FunctionType = Field(
        ...,
        description='The type of function. This determines when the function will be called.',
    )
    id: Optional[str] = Field(
        None,
        description='The ID qualifier for the function. This is used to specify which input field a function is associated with for `PRE_FETCH_OPTIONS` and `POST_FETCH_OPTIONS` function types.',
    )


class ActionLabels(BaseModel):
    actionCardContent: Optional[str] = Field(
        None,
        description='The label to be displayed in the action card of the workflow editor once this custom action has been added to a workflow.',
    )
    actionDescription: Optional[str] = Field(
        None,
        description='A description for this custom action. This will show up in the action editor along with the input fields.',
    )
    actionName: str = Field(
        ...,
        description='The name of this custom action. This is what will show up when users are selecting an action in the workflows app.',
    )
    appDisplayName: Optional[str] = Field(
        None,
        description='The name to be displayed at the top of the action editor in the workflows app.',
    )
    inputFieldDescriptions: Optional[Dict[str, str]] = Field(
        None,
        description='A map of input field names to descriptions for the fields. These will show up as tooltips when users are editing your action.',
    )
    inputFieldLabels: Optional[Dict[str, str]] = Field(
        None, description='A map of input field names to the user-facing labels.'
    )


class CallbackCompletionBatchRequest(BaseModel):
    callbackId: str = Field(..., description='The ID of the callback to complete.')
    outputFields: Dict[str, str] = Field(
        ..., description='A map of action output names and values.'
    )


class CallbackCompletionRequest(BaseModel):
    outputFields: Dict[str, str] = Field(
        ..., description='A map of action output names and values.'
    )


class CollectionResponseActionFunctionIdentifierNoPaging(BaseModel):
    results: List[ActionFunctionIdentifier]


class DependencyType(Enum):
    CONDITIONAL_SINGLE_FIELD = 'CONDITIONAL_SINGLE_FIELD'


class ConditionalSingleFieldDependency(BaseModel):
    controllingFieldName: str
    controllingFieldValue: str
    dependencyType: DependencyType
    dependentFieldNames: List[str]


class ErrorDetail(BaseModel):
    code: Optional[str] = Field(
        None, description='The status code associated with the error detail'
    )
    context: Optional[Dict[str, List[str]]] = Field(
        None,
        description='Context about the error condition',
        examples=[{'missingScopes': ['scope1', 'scope2']}],
    )
    in_: Optional[str] = Field(
        None,
        alias='in',
        description='The name of the field or parameter in which the error was found.',
    )
    message: str = Field(
        ...,
        description='A human readable message describing the error along with remediation steps where appropriate',
    )
    subCategory: Optional[str] = Field(
        None,
        description='A specific category that contains more specific detail about the error',
    )


class FieldType(Enum):
    booleancheckbox = 'booleancheckbox'
    checkbox = 'checkbox'
    date = 'date'
    file = 'file'
    number = 'number'
    phonenumber = 'phonenumber'
    radio = 'radio'
    select = 'select'
    text = 'text'
    textarea = 'textarea'
    calculation_equation = 'calculation_equation'
    calculation_rollup = 'calculation_rollup'
    calculation_score = 'calculation_score'
    calculation_read_time = 'calculation_read_time'
    unknown = 'unknown'


class ReferencedObjectType(Enum):
    CONTACT = 'CONTACT'
    COMPANY = 'COMPANY'
    DEAL = 'DEAL'
    ENGAGEMENT = 'ENGAGEMENT'
    TICKET = 'TICKET'
    OWNER = 'OWNER'
    PRODUCT = 'PRODUCT'
    LINE_ITEM = 'LINE_ITEM'
    BET_DELIVERABLE_SERVICE = 'BET_DELIVERABLE_SERVICE'
    CONTENT = 'CONTENT'
    CONVERSATION = 'CONVERSATION'
    BET_ALERT = 'BET_ALERT'
    PORTAL = 'PORTAL'
    QUOTE = 'QUOTE'
    FORM_SUBMISSION_INBOUNDDB = 'FORM_SUBMISSION_INBOUNDDB'
    QUOTA = 'QUOTA'
    UNSUBSCRIBE = 'UNSUBSCRIBE'
    COMMUNICATION = 'COMMUNICATION'
    FEEDBACK_SUBMISSION = 'FEEDBACK_SUBMISSION'
    ATTRIBUTION = 'ATTRIBUTION'
    SALESFORCE_SYNC_ERROR = 'SALESFORCE_SYNC_ERROR'
    RESTORABLE_CRM_OBJECT = 'RESTORABLE_CRM_OBJECT'
    HUB = 'HUB'
    LANDING_PAGE = 'LANDING_PAGE'
    PRODUCT_OR_FOLDER = 'PRODUCT_OR_FOLDER'
    TASK = 'TASK'
    FORM = 'FORM'
    MARKETING_EMAIL = 'MARKETING_EMAIL'
    AD_ACCOUNT = 'AD_ACCOUNT'
    AD_CAMPAIGN = 'AD_CAMPAIGN'
    AD_GROUP = 'AD_GROUP'
    AD = 'AD'
    KEYWORD = 'KEYWORD'
    CAMPAIGN = 'CAMPAIGN'
    SOCIAL_CHANNEL = 'SOCIAL_CHANNEL'
    SOCIAL_POST = 'SOCIAL_POST'
    SITE_PAGE = 'SITE_PAGE'
    BLOG_POST = 'BLOG_POST'
    IMPORT = 'IMPORT'
    EXPORT = 'EXPORT'
    CTA = 'CTA'
    TASK_TEMPLATE = 'TASK_TEMPLATE'
    AUTOMATION_PLATFORM_FLOW = 'AUTOMATION_PLATFORM_FLOW'
    OBJECT_LIST = 'OBJECT_LIST'
    NOTE = 'NOTE'
    MEETING_EVENT = 'MEETING_EVENT'
    CALL = 'CALL'
    EMAIL = 'EMAIL'
    PUBLISHING_TASK = 'PUBLISHING_TASK'
    CONVERSATION_SESSION = 'CONVERSATION_SESSION'
    CONTACT_CREATE_ATTRIBUTION = 'CONTACT_CREATE_ATTRIBUTION'
    INVOICE = 'INVOICE'
    MARKETING_EVENT = 'MARKETING_EVENT'
    CONVERSATION_INBOX = 'CONVERSATION_INBOX'
    CHATFLOW = 'CHATFLOW'
    MEDIA_BRIDGE = 'MEDIA_BRIDGE'
    SEQUENCE = 'SEQUENCE'
    SEQUENCE_STEP = 'SEQUENCE_STEP'
    FORECAST = 'FORECAST'
    SNIPPET = 'SNIPPET'
    TEMPLATE = 'TEMPLATE'
    UNKNOWN = 'UNKNOWN'


class Type(Enum):
    string = 'string'
    number = 'number'
    bool = 'bool'
    datetime = 'datetime'
    enumeration = 'enumeration'
    date = 'date'
    phone_number = 'phone_number'
    currency_number = 'currency_number'
    json = 'json'
    object_coordinates = 'object_coordinates'


class SupportedValueType(Enum):
    STATIC_VALUE = 'STATIC_VALUE'
    OBJECT_PROPERTY = 'OBJECT_PROPERTY'
    FIELD_DATA = 'FIELD_DATA'


class NextPage(BaseModel):
    after: str
    link: Optional[str] = None


class ObjectRequestOptions(BaseModel):
    properties: List[str] = Field(
        ...,
        description='A list of properties of the CRM object to include with the request to the `actionUrl`.',
    )


class Option(BaseModel):
    description: str
    displayOrder: int
    doubleData: float
    hidden: bool_aliased
    label: str = Field(..., description='The user-facing label for the option.')
    readOnly: bool_aliased
    value: str = Field(
        ...,
        description='The internal value for the option. This is what will be included in the execution request to the `actionUrl`.',
    )


class DependencyType1(Enum):
    SINGLE_FIELD = 'SINGLE_FIELD'


class SingleFieldDependency(BaseModel):
    controllingFieldName: str
    dependencyType: DependencyType1
    dependentFieldNames: List[str]


class BatchInputCallbackCompletionBatchRequest(BaseModel):
    inputs: List[CallbackCompletionBatchRequest]


class Error(BaseModel):
    category: str = Field(..., description='The error category')
    context: Optional[Dict[str, List[str]]] = Field(
        None,
        description='Context about the error condition',
        examples=[
            {
                'invalidPropertyName': ['propertyValue'],
                'missingScopes': ['scope1', 'scope2'],
            }
        ],
    )
    correlationId: UUID = Field(
        ...,
        description='A unique identifier for the request. Include this value with any error reports or support tickets',
        examples=['aeb5f871-7f07-4993-9211-075dc63e7cbf'],
    )
    errors: Optional[List[ErrorDetail]] = Field(
        None, description='further information about the error'
    )
    links: Optional[Dict[str, str]] = Field(
        None,
        description='A map of link names to associated URIs containing documentation about the error or recommended remediation steps',
    )
    message: str = Field(
        ...,
        description='A human readable message describing the error along with remediation steps where appropriate',
        examples=['An error occurred'],
    )
    subCategory: Optional[str] = Field(
        None,
        description='A specific category that contains more specific detail about the error',
    )


class FieldTypeDefinition(BaseModel):
    fieldType: Optional[FieldType] = Field(
        None, description='Controls how the field appears in HubSpot.'
    )
    name: str = Field(..., description='The input field name.')
    options: List[Option] = Field(
        ..., description='A list of valid options for the field value.'
    )
    optionsUrl: Optional[str] = Field(
        None,
        description='A URL that will accept HTTPS requests when the valid options for the field are fetched.',
    )
    referencedObjectType: Optional[ReferencedObjectType] = Field(
        None,
        description='This can be set to `OWNER` if the field should contain a HubSpot owner value.',
    )
    type: Type = Field(..., description='The data type of the field.')


class ForwardPaging(BaseModel):
    next: Optional[NextPage] = None


class InputFieldDefinition(BaseModel):
    isRequired: bool_aliased = Field(
        ...,
        description='Whether the field is required for the custom action to be valid',
    )
    supportedValueTypes: Optional[List[SupportedValueType]] = Field(
        None,
        description='Controls what kind of input a customer can use to specify the field value. Must contain exactly one of `STATIC_VALUE` or `OBJECT_PROPERTY`. If `STATIC_VALUE`, the customer will be able to choose a value when configuring the custom action; if `OBJECT_PROPERTY`, the customer will be able to choose a property from the enrolled workflow object that the field value will be copied from. In the future we may support more than one input control type here.',
    )
    typeDefinition: FieldTypeDefinition


class ExtensionActionDefinition(BaseModel):
    actionUrl: str = Field(
        ...,
        description='The URL that will accept an HTTPS request each time workflows executes the custom action.',
    )
    archivedAt: Optional[int] = Field(
        None,
        description='The date that this custom action was archived, if the custom action is archived.',
    )
    functions: List[ActionFunctionIdentifier] = Field(
        ...,
        description='A list of functions associated with the custom workflow action.',
    )
    id: str = Field(..., description='The ID of the custom action.')
    inputFieldDependencies: Optional[
        List[Union[SingleFieldDependency, ConditionalSingleFieldDependency]]
    ] = Field(
        None,
        description='A list of dependencies between the input fields. These configure when the input fields should be visible.',
    )
    inputFields: List[InputFieldDefinition] = Field(
        ..., description='The list of input fields to display in this custom action.'
    )
    labels: Dict[str, ActionLabels] = Field(
        ..., description='The user-facing labels for the custom action.'
    )
    objectRequestOptions: Optional[ObjectRequestOptions] = None
    objectTypes: List[str] = Field(
        ..., description='The object types that this custom action supports.'
    )
    published: bool_aliased = Field(
        ..., description='Whether this custom action is published to customers.'
    )
    revisionId: str


class ExtensionActionDefinitionInput(BaseModel):
    actionUrl: str = Field(
        ...,
        description='The URL that will accept an HTTPS request each time workflows executes the custom action.',
    )
    archivedAt: Optional[int] = Field(
        None,
        description='The date that this custom action was archived, if the custom action is archived.',
    )
    functions: List[ActionFunction] = Field(
        ...,
        description='A list of functions associated with the custom workflow action.',
    )
    inputFieldDependencies: Optional[
        List[Union[SingleFieldDependency, ConditionalSingleFieldDependency]]
    ] = Field(
        None,
        description='A list of dependencies between the input fields. These configure when the input fields should be visible.',
    )
    inputFields: List[InputFieldDefinition] = Field(
        ..., description='The list of input fields to display in this custom action.'
    )
    labels: Dict[str, ActionLabels] = Field(
        ..., description='The user-facing labels for the custom action.'
    )
    objectRequestOptions: Optional[ObjectRequestOptions] = None
    objectTypes: List[str] = Field(
        ..., description='The object types that this custom action supports.'
    )
    published: bool_aliased = Field(
        ..., description='Whether this custom action is published to customers.'
    )


class ExtensionActionDefinitionPatch(BaseModel):
    actionUrl: Optional[str] = Field(
        None,
        description='The URL that will accept an HTTPS request each time workflows executes the custom action.',
    )
    inputFieldDependencies: Optional[
        List[Union[SingleFieldDependency, ConditionalSingleFieldDependency]]
    ] = Field(
        None,
        description='A list of dependencies between the input fields. These configure when the input fields should be visible.',
    )
    inputFields: Optional[List[InputFieldDefinition]] = Field(
        None, description='The list of input fields to display in this custom action.'
    )
    labels: Optional[Dict[str, ActionLabels]] = Field(
        None, description='The user-facing labels for the custom action.'
    )
    objectRequestOptions: Optional[ObjectRequestOptions] = None
    objectTypes: Optional[List[str]] = Field(
        None, description='The object types that this custom action supports.'
    )
    published: Optional[bool_aliased] = Field(
        None, description='Whether this custom action is published to customers.'
    )


class ActionRevision(BaseModel):
    createdAt: datetime_aliased = Field(
        ..., description='The date the revision was created.'
    )
    definition: ExtensionActionDefinition
    id: str
    revisionId: str = Field(..., description='The version number of the custom action.')


class CollectionResponseActionRevisionForwardPaging(BaseModel):
    paging: Optional[ForwardPaging] = None
    results: List[ActionRevision]


class CollectionResponseExtensionActionDefinitionForwardPaging(BaseModel):
    paging: Optional[ForwardPaging] = None
    results: List[ExtensionActionDefinition]
